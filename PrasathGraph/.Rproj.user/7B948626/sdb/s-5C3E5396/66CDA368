{
    "contents" : "nodeRange <- function(graph, start, maxn){\n  \n  r <- list();\n  r[[1]] <- start;\n  \n  for(i in 1:maxn){\n    v <- as.character(r[[i]]);\n    r[[i + 1]] <- as.character(unlist(neighborhood(graph,v)))\n  }\n  \n  return(unique(unlist(r)));\n}\n\n# graph : object of class 'graph' representing pathway\n#         (or subset of pathway) to be plotted.\n# de    : log2 fold change, entrez GeneID named vector\n#         of differentially expressed genes/proteins.\n# organism: 3-letter KEGG code of organism \n#           (e.g., \"mmu\" for mouse).\n# cols  : vector of colours indicating heatmap gradient.\n# all   : entrez GeneID character vector of background\n#         genes/proteins.\npathwayHeatmap <- function(graph,layout=\"fdp\",de,cols,subGList=list(),nodeAttrs=list(),attrs=list()){\n  require(graph);\n  \n  deKID <- names(de);\n  allKID <- all;\n  \n  # Retrieves the log2FC of nodes in the graph from 'de'.\n  logfc <- de[match(nodes(graph),deKID)];\n  \n  # Annotates logfcs with node names.\n  names(logfc) <- nodes(graph); \n  \n  # NA values in logfc are nodes that were not in 'de'; set\n  # values to 0.\n  logfc[is.na(logfc)] <- 0;\n  \n  # Translate logfcs so that ~0 values are equal to half the\n  # length of the cols vector. These values represent small\n  # fold change between the two classes are mapped to the\n  # colour corresponding to small FC (i.e., middle colour).\n  incol <- round(logfc + trunc(length(cols)/2));\n  incol[incol > length(cols)] <- length(cols);\n  incol[incol < 0] <- 1;\n  \n  # Identify if nodes in the graph were detected in the\n  # background. *May or may not keep this.*\n  #undetected <- !nodes(graph) %in% allKID;\n  \n  logcol <- cols[incol];\n  logcol[logfc==0] <- \"darkgrey\";\n  \n  names(logcol) <- names(logfc);\n  \n  nAttrs <- nodeAttrs;\n  nAttrs$fillcolor <- logcol;\n  \n  if(!length(globalAttrs)){\n    attrs=list(node=list(shape=\"circle\",\n                         fontsize=20,\n                         fixedsize=T),\n               edge=list(arrowsize=\"0.6\"));\n  }\n  if(length(subGList)){\n    plot(graph,\n         layout,\n         subGList=subGList,\n         nodeAttrs = nAttrs,\n         attrs = attrs);\n  }else{\n    plot(graph,\n         layout,\n         nodeAttrs = nAttrs,\n         attrs = attrs);\n  }\n}\n\n\n# Assume graph will be annotated with geneID \n# (which is true if generated using 'graphite' package).\nsmartSubsetter <- function(graph,de){\n  require(graph);\n  \n  # Retrieve entrezID of pathway nodes found in differentially expressed list.\n  sigNodes <- names(de)[match(nodes(graph),names(de))];\n  \n  # Remove NA's. These represent nodes in the pathway were not identified in the differentially\n  # expressed list. \n  sigNodes <- sigNodes[!is.na(sigNodes)];\n  \n  return(subGraph(sigNodes,graph));\n}\n\n# Recursive function returns all nodes that connect *TO* given node, 'node',\n# from all top-level nodes (nodes that don't have any incoming edges).\ninRecurse <- function(node,graph,s=vector()){\n  r <- vector();\n  iE <- unlist(inEdges(node,graph));\n  iE <- iE[!(iE %in% s)];\n  if(!length(iE)){\n    return(node);\n  }else{\n    r <- c(r,node);\n    for(i in 1:length(iE)){\n      r <- c(r,inRecurse(iE[i],graph,r));\n    }\n    r <- unname(r);\n    return(r);\n  }\n}\n\noutRecurse <- function(node,graph,s=vector()){\n  r <- vector();\n  oE <- unlist(edges(graph)[node]);\n  oE <- oE[!(oE %in% s)];\n  if(!length(oE)){\n    return(node);\n  }else{\n    r <- c(r,node);\n    for(i in 1:length(oE)){\n      r <- c(r,outRecurse(oE[i],graph,r));\n    }\n    r <- unname(r);\n    return(r);\n  }\n}\n\nconvertKEGGID2Entrez <- function(kegg){\n  r <- vector();\n  for(i in 1:length(kegg)){\n    r <- c(r,unlist(strsplit(kegg[i],\":\"))[2]);\n  }\n  return(r);\n}\n\n# mapEntrez2Symbol <- function(entrez){\n#   require(org.Mm.eg.db);\n#   return(sapply(mget(entrez, org.Mm.egSYMBOL, ifnotfound=NA), \"[[\",1));\n# }\n# \n# createNodeLabelsVector <- function(graph){\n#   entrez <- convertKEGGID2Entrez(nodes(graph));\n#   symbols <- mapEntrez2Symbol(entrez);\n#   names(symbols) <- nodes(graph);\n#   return(symbols);\n# }\n\nmapNodes2Symbols <- function(graph,env){\n  require(graph);\n  symbs <- sapply(mget(nodes(graph),env,ifnotfound=NA),\"[[\",1);\n  names(symbs) <- nodes(graph);\n  return(symbs);\n}\n\nupstreamSearcher <- function(graph,node){\n  require(graph);\n  \n  inPath <- unlist(inEdges(node,graph));\n  alreadyChecked <- node;\n  \n  while(length(inPath) > 0){\n    addToInPath <- vector();\n    for(i in 1:length(inPath)){\n      currNode <- inPath[i];\n      \n      if(currNode %in% alreadyChecked){\n        next;\n      }\n      moreConnections <- unlist(inEdges(currNode,graph));\n      moreConnections <- moreConnections[!(moreConnections %in% alreadyChecked)];\n      if(length(moreConnections)){\n        addToInPath <- c(addToInPath,moreConnections);\n      }\n      alreadyChecked <- c(alreadyChecked,currNode);\n    }\n    inPath <- addToInPath[!(addToInPath %in% alreadyChecked)];\n  }\n  alreadyChecked <- unname(alreadyChecked);\n  return(alreadyChecked);\n}\n\ndownstreamSearcher <- function(graph,node){\n  require(graph);\n  \n  outPath <- unlist(edges(graph)[node]);\n  alreadyChecked <- node;\n  \n  while(length(outPath) > 0){\n    addToOutPath <- vector();\n    for(i in 1:length(outPath)){\n      currNode <- outPath[i];\n      \n      if(currNode %in% alreadyChecked){\n        next;\n      }\n      \n      moreConnections <- unlist(edges(graph)[currNode]);\n      moreConnections <- moreConnections[!(moreConnections %in% alreadyChecked)];\n      if(length(moreConnections)){\n        addToOutPath <- c(addToOutPath,moreConnections);\n      }\n      alreadyChecked <- c(alreadyChecked,currNode);\n    }\n    outPath <- addToOutPath[!(addToOutPath %in% alreadyChecked)];\n  }\n  alreadyChecked <- unname(alreadyChecked);\n  return(alreadyChecked);\n}\n######################### FUNCTIONS ###################################\nexecuteRead = function(curr=getwd()){\n  library(oligo,quietly=T)\n  celFiles = list.celfiles(curr)\n  raw = read.celfiles(celFiles)\n  raw # return\n}\n\ngenerateQC = function(sampleName, genefeatureset){\n  library(oligo,quietly=T)\n  boxplotName = paste(sampleName, \"boxplot.png\", sep=\"_\")\n  MAPlotName = paste(sampleName, \"MAplot.png\", sep=\"_\")\n  \n  png(boxplotName, width=2000,height=2000)\n  boxplot(genefeatureset,col=\"red\")\n  dev.off()\n  \n  png(MAPlotName, width=2000, height=2000)\n  par(mfrow=c(2,3))\n  MAPlot(genefeatureset)\n  dev.off()\n}\n\ngenerateFit = function(design,expV,eset){\n  library(limma,quietly=T)\n  fit = lmFit(eset,design)\n  cont = makeContrasts(contrasts=expV,levels=design)\n  fit2 = contrasts.fit(fit,cont)\n  fit2 = eBayes(fit2)\n  fit2 # return\n}\n\ngenerateAnnotDataFrame = function(envs){\n  df = data.frame()\n  if(length(envs) < 1){\n    print(\"Need a list of key-map environments.\")\n  }else{\n    for(i in 1:length(envs)){\n      if(class(envs[[i]])[1] == \"ProbeAnnDbBimap\"){\n        if(i == 1){\n          df = sapply(contents(envs[[i]]),paste,collapse=\", \")\n        }else{\n          df = merge(df,sapply(contents(envs[[i]]),paste,collapse=\", \"),all=T,by=0)\n          df = setAndRemoveRowNames(df,1)          \n        }\n      }\n    }\n  }\n  df # return\n}\n\nsetAndRemoveRowNames = function(df, rowCol){\n  rownames(df) = df[,rowCol]\n  if(rowCol == 1){\n    df = df[,2:ncol(df)]\n  }else{\n    df = df[,c(1:(rowCol - 1),(rowCol + 1):ncol(df))]\n  }\n  df #return\n}\n\n#bcell.probeset.annot.sorted.omitted[bcell.probeset.annot.sorted.omitted$SYMBOL == l[5000],]\n\naverageAndCollapse = function(df,lev, factorColName, columnsToSelect){\n  r = data.frame()\n  for(i in 1:length(lev)){\n    s = subset(df, factorColName == lev[i], select=columnsToSelect)\n    df = df[factorColName != lev[i],]\n    m = apply(s,2,mean)\n    r = rbind(r,m)\n  }\n  rownames(r) = lev\n  colnames(r) = columnsToSelect\n  r #return\n}\n\ncreateColoursFromFactor <- function(factor, colours){\n  if(length(colours) < length(levels(factor))){\n    print(\"Error: The number of colours must equal the number of levels within the factor.\")\n  }else{\n    iFactor <- as.integer(factor)\n    colVector <- vector()\n    for(i in 1:length(iFactor)){\n      colVector <- c(colVector, colours[iFactor[i]])\n    }\n    colVector # return\n  }\n}\n################################################################################################\n# Description\n# Evalutes vector representing a protein's LFQ and peptide count values to determine\n# whether to use LFQ or not for this protein.\n#\n# Usage\n# decide(x,f,lfq,pep)\n#  \n# Arguments\n# x: dataframe vector that must contain LFQ, iBAQ and peptide count values for a single protein.\n# f: factor describing classes of data and the position of their replicates within x.\n# lfq: numeric vector indicating column numbers of lfq values in x.\n# pep: numeric vector indicating column numbers of peptide count values in x.\n#\n# Value\n# Returns a boolean indicating whether to use LFQ values or not for the protein from the given\n# vector.\n#\n################################################################################################\ndecide <- function(x,f,lfq,pep){\n  xlfq <- as.numeric(x[lfq])\n  xpep <- as.numeric(x[pep])\n  \n  lfq_switch <- F\n  for(i in 1:length(levels(f))){\n    class_cols <- as.integer(f) == i\n    if(all(xlfq[class_cols] > 0)){ # *all* lfq values in class greater than 0\n      lfq_switch <- T\n    }else{ # *not all* lfq values in class greater than 0      \n      if(all(xlfq[class_cols] == 0)){ # *all* lfq values are 0\n        if(all(xpep[class_cols] == 0)){ # *all* peptide counts are 0; lfq 0's represent 0 sample quantity\n          lfq_switch <- T\n        }else{ # *not all* peptide counts are 0; lfq 0's represent insufficient data\n          lfq_switch <- F\n        }\n      }else{ # *not all* lfq values are 0\n        lfq_switch <- F\n      }\n    }\n    \n    # if lfq values should still be used?continue loop:exit loop (and use iBAQ) \n    if(!lfq_switch){\n      break\n    }\n  }\n  \n  return(lfq_switch) # return bool of whether to use lfq or not for this protein\n}\n\n\n# Assume normality of differences in protein steady-state abundance between two samples/treatments.\n# \n# Determine differences between samples/treatments by finding the difference of tissue replicates in\n# combination of sample 1 and sample 2 replicates for each protein.\n#\n# Determine mean of the differences for each protein. \n\n# Given a matrix and integer vectors indicating which columns within the matrix are sample 1\n# replicates and which columns are sample 2 replicates, returns a matrix containing the \n# pairwise log fold change for every combination of sample 1 and sample 2 replicates.\n# NOTE: NaN values are preserved.\ncomputeCombFoldChange = function(df, s1r=c(1:2), s2r=c(3:4)){\n  comb = combination(s1r,s2r)\n  a = vector()\n  for(i in 1:nrow(df)){\n    v = combFoldChange(df[i,],comb)\n    a = rbind(a,v)\n  }\n  colnames(a) = createCombColNames(colnames(df),comb,sepChr=\"/\")\n  rownames(a) = rownames(df)\n  a #return\n}\n\n# Given a matrix and integer vectors indicating which columns within the matrix are \n# sample 1 replicates and which columns are sample 2 replicates, returns a matrix\n# containing the pairwise difference for every combination of sample 1 and sample 2 replicates.\ncomputeCombDiff = function(df, s1r=c(1:2), s2r=c(3:4)){\n  comb = combination(s1r,s2r)\n  a = vector()\n  for(i in 1:nrow(df)){\n    v = combDiff(df[i,],comb)\n    a = rbind(a,v)\n  }\n  colnames(a) = createCombColNames(colnames(df),comb)\n  rownames(a) = rownames(df)\n  a #return\n}\n\n# Given a single vector of numerical values and a matrix containing every combination\n# of replicate pairs between two samples/treatments, calculate the difference in replicate \n# values for every combination of sample 1 and sample 2 replicates.\ncombDiff = function(v, comb) {  \n  a = vector()\n  for(i in 1:nrow(comb)){\n    p = comb[i,1]\n    q = comb[i,2]\n    a = cbind(a, v[1,p] - v[1,q])\n  }\n  a #return\n}\n\n# Given a single vector of numerical values and a matrix containing every combination\n# of replicate pairs between two samples/treatments, calculate the log fold change in \n# replicate values for every combination of sample 1 and sample 2 replicates.\ncombFoldChange = function(v, comb){\n  a = vector()\n  for(i in 1:nrow(comb)){\n    p = comb[i,1]\n    q = comb[i,2]\n    a = cbind(a, v[1,p]/v[1,q])\n  }\n  a #return\n}\n\n# Given a column name vector and a matrix containing every combination of replicate pairs\n# between two samples/treatments, create column labels for replicate combinations.\ncreateCombColNames = function(colNames, comb, sepChr=\" - \"){\n  newCols = vector()\n  for(i in 1:nrow(comb)){\n    p = comb[i,1]\n    q = comb[i,2]\n    newCols = rbind(newCols,paste(colNames[p], colNames[q], sep=sepChr))\n  }\n  newCols #return\n}\n\n# Given a vector containing integers and another vector containing integers,\n# returns a matrix containing every combination of integer pairs from the two \n# input vectors.\ncombination = function(s1r, s2r){\n  a = vector()\n  for(i in 1:length(s1r)){\n    for(j in 1:length(s2r)){\n      a = rbind(a,c(s1r[i],s2r[j]))\n    }\n  }\n  a #return\n}\n\n# Extract uniprot accession numbers and use the first uniprot accession \n# if there are more than one.\nextractUniprotAcc <- function(v){\n  x <- vector()\n  for(i in 1:length(v)){\n    id <- v[i]\n    x <- cbind(x,unlist(strsplit(id,\";\"))[1])\n  }\n  return(as.character(x))\n}\n\n# Given a numerical matrix, this function will convert 0 values to 1.\n# This function is useful for when 0 values will result in Inf fold changes.\nconvertZerosToOnes <- function(m){\n  cleaned <- vector()\n  for(i in 1:nrow(m)){\n    r <- m[i,]\n    for(j in 1:length(r)){\n      if(r[j] == 0){\n        r[j] = 1\n      }\n    }\n    cleaned <-rbind(cleaned,r)\n  }\n  return(cleaned)\n}\n\n# Function to collapse duplicated rows after merging of dataframe during\n# annotations. This function is slow :(\ncollapser <- function(df,collapseOn){\n  newDF <- data.frame();\n  uniq <- unique(df[,collapseOn]);\n  for(i in 1:length(uniq)){\n    newDF <- rbind(newDF,as.data.frame(df[df[,collapseOn]==uniq[i],][1,]));\n  }\n  return(newDF);\n}\n\n# Convert a list of clusters into subgraph list that can be input into plot(signature=graphNEL).\n# Node names must be the same as that of cluster nodes.\nconvertClusterToSubGList <- function(cluster,graphToBePlotted,attrs=vector()){\n  require(graph);\n  subGList <- list();\n  for(i in 1:length(cluster)){\n    if(length(attrs) == 0){\n      subList <- list(graph=subGraph(cluster[[i]],graphToBePlotted));\n    }else{\n      subList <- list(graph=subGraph(cluster[[i]],graphToBePlotted),attrs=attrs);\n    }\n    \n    subGList[[i]] <- subList;\n  }\n  return(subGList);\n}\n\n# Assumes masterEdges is a dataframe as produced by the graphite::edges() function on a pathway.\nf1 <- function(masterEdges){\n  edges <- masterEdges;\n  sortedByConn <- names(sort(table(factor(edges[,1])),decreasing=T));\n  cluster <- list();\n  singles <- vector();\n  clustersCount <- 1;\n  \n  # Seed Phase\n  while(length(sortedByConn) > 0){\n    topNode <- sortedByConn[1];\n    level1Nodes <- edges[edges[,1] == topNode,2];\n    returnedCluster <- f2(level1Nodes,edges);\n    returnedCluster <- c(topNode,returnedCluster);\n    sortedByConn <- sortedByConn[!sortedByConn %in% returnedCluster];\n    edges <- edges[!edges[,1] %in% returnedCluster,];\n    if(length(returnedCluster) > 1){\n      cluster[[clustersCount]] <- returnedCluster;\n      clustersCount <- clustersCount + 1;\n    }else{\n      singles <- c(singles,returnedCluster);\n    }\n  }\n  \n  # Merge Phase\n  limit <- 100;\n  limitCounter <- 0;\n  lastSingleLength <- length(singles);\n  \n  while(length(singles) > 0){\n    for(i in 1:length(singles)){\n      level1Nodes <- masterEdges[masterEdges[,1] == singles[i],2];\n      bestOverlapScore <- 0;\n      bestClusterIndex <- 1;\n      for(j in 1:length(cluster)){\n        numOverlap <- sum(level1Nodes %in% cluster[[j]]);\n        if(numOverlap >= bestOverlapScore){\n          bestOverlapScore <- numOverlap;\n          bestClusterIndex <- j;\n        }\n      }\n      if(bestOverlapScore > 0){\n        cluster[[bestClusterIndex]] <- c(cluster[[bestClusterIndex]],singles[i]);\n        singles <- singles[!singles %in% singles[i]];\n      }\n    }\n    \n    # Stop looping if the number of elements in the singles vector does not change\n    currentSinglesLength <- length(singles);\n    if(currentSinglesLength == lastSingleLength){\n      limitCounter <- limitCounter + 1;\n      if(limitCounter > limit){\n        break;\n      }\n    }else{\n      limitCounter <- 0;\n    }\n    lastSingleLength <- currentSinglesLength;\n  }\n  \n  #return(singles);\n  return(cluster);\n}\nf2 <- function(level1Nodes,edges){\n  bestOverlapScore <- 0;\n  newTopNode <- vector();\n  remainingNodes <- vector();\n  for(i in 1:length(level1Nodes)){\n    level1Node <- level1Nodes[i];\n    level2Nodes <- edges[edges[,1] == level1Node,2];\n    if(length(level2Nodes) > 0){\n      overlappingNodes <- level2Nodes[level2Nodes %in% level1Nodes];\n      numOverlap <- length(overlappingNodes);\n      if(numOverlap > bestOverlapScore){\n        bestOverlapScore <- numOverlap;\n        newTopNode <- level1Node;\n        remainingNodes <- overlappingNodes;\n      }else if(numOverlap == bestOverlapScore){\n        newTopNode <- c(newTopNode,level1Node);\n        remainingNodes <- unique(c(remainingNodes,overlappingNodes));\n      }\n    }\n  }\n  if(length(remainingNodes) > 0){\n    newTopNode<- c(newTopNode,f2(remainingNodes,edges));\n  }\n  return(newTopNode);\n}\n\nfindBindings <- function(bindings,graphEdgeNames){\n  isABindingEdge <- vector();\n  for(i in 1:length(graphEdgeNames)){\n    edgeNodes <- unlist(strsplit(graphEdgeNames[i],\"~\"));\n    src <- edgeNodes[1];\n    dest <- edgeNodes[2];\n    \n    srcBindings <- bindings[bindings[,1] == src,2];\n    if(dest %in% srcBindings){\n      isABindingEdge <- c(isABindingEdge, graphEdgeNames[i]);\n      next;\n    }\n    \n    destBindings <- bindings[bindings[,2] == src,1];\n    if(dest %in% destBindings){\n      isABindingEdge <- c(isABindingEdge,graphEdgeNames[i]);\n      next;\n    }\n  }\n  return(isABindingEdge);\n}\n",
    "created" : 1407297108580.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1502648243",
    "id" : "66CDA368",
    "lastKnownWriteTime" : 1407297233,
    "path" : "~/OCI/prasath_functions _full.R",
    "project_path" : null,
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}